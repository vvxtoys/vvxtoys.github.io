<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用nexus3.x搭建maven私服]]></title>
    <url>%2F2018%2F09%2F19%2F%E4%BD%BF%E7%94%A8nexus3.x%E6%90%AD%E5%BB%BAmaven%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[前言 好久之前就想搭建maven仓库了，一直拖到了现在，也就是懒得动，现在终于是要付诸行动了。网上查了不少资料，好多博客都是关于2.x的搭建，我下载的是最新版的nexus，好多教程已经不能使用，以此记录我的踩坑搭建之路。 安装环境和需要的软件 Centos 7 Java 1.8 nexus OSS 3.13 Java安装 卸载openjdk 121.rpm -qa|grep java 查找2.rpm -e --nodeps xxxx 卸载openjdk 下载jdk 1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz&quot; 安装 12345678910111213141.mkdir /usr/java 在/usr下建立Java文件夹2.mv jdk-8u181-linux-x64.tar.gz /usr/java/jdk-8u181-linux-x64.tar.gz3.tar -xzvf jdk-8u181-linux-x64.tar.gz 解压4.mv jdk1.8.0_181/ jdk1.85.vim /etc/profile6.设置环境变量JAVA_HOME=/usr/java/jdk1.8JRE_HOME=/usr/java/jdk1.8/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPARH=,:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH分隔符是冒号不是分号7.source /etc/profile 使环境变量生效8.java -version 查看Java版本 Nexus安装 创建文件夹 1mkdir /usr/software/nexus 下载安装文件 12cd /usr/software/nexuswget &quot;https://sonatype-download.global.ssl.fastly.net/repository/repositoryManager/3/nexus-3.13.0-01-unix.tar.gz&quot; 解压 1tar -xzvf nexus-3.13.0-01-unix.tar.gz 解压后 修改配置文件 也可以不改 12cd nexus-3.13.0-01/etcvim nexus-default.properties 默认端口8081,我修改为5743 开放端口 root用户 123456789101.查看防火墙状态firewall-cmd --state2.如果关闭开启防火墙systemctl start firewalld.service3.开放5743端口(以自己的配置为准)firewall-cmd --zone=public --add-port=5743/tcp --permanent 4.重新加载firewall-cmd --reload5.重启防火墙systemctl restart firewalld.service 启动nexus 12345cd nexus-3.13.0-01/bin./nexus start常用命令./nexus restart./nexus stop 本地访问 ip:端口号 默认账户admin 密码 admin123 选择Repositories 创建三方私有库 我创建了两个maven hosted仓库 将这两个仓库加入到maven-public中 点击maven-public 到这里线上就配置完成了 配置Maven 找到setting.xml 在mirrors中添加mirror 123456&lt;mirror&gt; &lt;id&gt;nexus&lt;/id &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;central repository&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/maven-public/&lt;/url&gt;&lt;/mirror&gt; 在servers中添加server 12345678910111213141516&lt;!-- id与pom.xml中的distributionManagement下repository的id对应 --&gt;&lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;3rd-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;3rd-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 在profiles中添加profile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;profile&gt;&lt;id&gt;nexus&lt;/id&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;3rd-releases&lt;/id&gt; &lt;name&gt;3rd releases&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-releases/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;3rd-snapshots&lt;/id&gt; &lt;name&gt;3rd snapshots&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-snapshots/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt; &lt;id&gt;3rd-releases&lt;/id&gt; &lt;name&gt;3rd releases&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-releases/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;3rd-snapshots&lt;/id&gt; &lt;name&gt;3rd snapshots&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-snapshots/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;/profile&gt; 激活profile 1234&lt;activeProfiles&gt;&lt;!--profile下的id--&gt;&lt;activeProfile&gt;nexus&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 上传jar 发布项目 网页上传jar upload maven deploy pom.xml 添加 distributionManagement 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;3rd-releases&lt;/id&gt; &lt;name&gt;3rd-releases&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;3rd-snapshots&lt;/id&gt; &lt;name&gt;3rd-snapshots&lt;/name&gt; &lt;url&gt;http://ip:端口/repository/3rd-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; id要和setting.xml中的server id一致 运行maven deploy 查看线上 发布成功,以后可以直接在别的项目中使用]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vgenerator(三)]]></title>
    <url>%2F2018%2F07%2F11%2Fvgenerator3%2F</url>
    <content type="text"><![CDATA[前言该项目的最后一篇博文，最终构建，写入文件，整体项目流程将在本片文章中写出。 jdbcType1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/***@author vvxtoys*mysql单位 -&gt; jdbcType*/package cc.vvxtoys.bean;public enum JdbcType &#123; DATE(",date,year,"), LONGVARCHAR(",longtext,text,mediumtext,"), INTEGER(",int,mediumint,"), REAL(",float,"), OTHER(",point,multipoint,multilinestring,multipolygon,polygon,geometrycollection,linestring,"), TINYINT(",tinyint,"), BIGINT(",bigint,"), TIMESTAMP(",datetime,timestamp,"), VARCHAR(",varchar,tinytext,"), BINARY(",tinyblob,binary,geometry,"), CHAR(",enum,char,set,"), DOUBLE(",double,"), BIT(",bit,"), SMALLINT(",smallint,"), LONGVARBINARY(",mediumblob,blob,longblob,"), DECIMAL(",decimal,"), VARBINARY(",varbinary,"), TIME(",time,"); private String type; private JdbcType(String type) &#123; this.type = type; &#125; public String getType() &#123; return type; &#125; public static String getJdbcType(String dbtype)&#123; if(dbtype.indexOf("(")!=-1)&#123; dbtype = dbtype.substring(0,dbtype.indexOf("(")); &#125; dbtype = ","+dbtype+","; for(JdbcType jdbc:JdbcType.values())&#123; if(jdbc.getType().indexOf(dbtype)!=-1)&#123; return jdbc.name(); &#125; &#125; return "OTHER"; &#125;&#125; 生成xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328/***@author vvxtoys*添加xml节点*/package cc.vvxtoys.vgenerator;import java.util.Map;import cc.vvxtoys.bean.XMLBean;import cc.vvxtoys.factory.MapperFactory;import cc.vvxtoys.utils.Vconst;public class SqlGenerator &#123; private XMLBean xml; private int k_size;//主键数 private int c_size;//去除主键列数 private String column; private String endText = "";//最后一行 where id = "" public static Map&lt;String,String&gt; keys; //主键 name = jdbctype public static Map&lt;String,String&gt; columns;//列 name = jdbctype public SqlGenerator(XMLBean xml) &#123; this.xml = xml; &#125; public void generatorSql()&#123; if(k_size&gt;0)&#123; generator1(); &#125;else&#123; generator2(); &#125; &#125; private void generator1()&#123; addResultMap(); addSql(); addInsert1(); addInsert2(); addSelect(); addDelete(); addUpdate1(); addUpdate2(); &#125; private void generator2()&#123; addResultMap(); addSql(); addInsert1(); addInsert2(); &#125; private void addResultMap()&#123; column = ""; int count = 0; XMLBean resultMap = new XMLBean("resultMap"); xml.addElement(resultMap); resultMap.init(); resultMap.addAttribute("id", "BaseResultMap"); resultMap.addAttribute("type", xml.getPojo()); if(k_size&gt;0)&#123; for(String key:keys.keySet())&#123; XMLBean id = new XMLBean("id"); resultMap.addElement(id); id.init(); id.addAttribute("column", key); id.addAttribute("property", key); id.addAttribute("jdbcType", keys.get(key)); if(count&gt;10)&#123; column+="\n"; count=0; &#125; column+=","+key; count++; setEndText(key, keys.get(key)); &#125; &#125; if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; XMLBean result = new XMLBean("result"); resultMap.addElement(result); result.init(); result.addAttribute("column", key); result.addAttribute("property", key); result.addAttribute("jdbcType", columns.get(key)); if(count&gt;10)&#123; column+="\n"; count=0; &#125; column+=","+key; count++; &#125; &#125; &#125; private void addSql()&#123; XMLBean sql = new XMLBean("sql"); xml.addElement(sql); sql.init(); sql.addAttribute("id", "Base_Column_List"); sql.addText(column.substring(1)); &#125; private void addSelect()&#123; XMLBean select = new XMLBean("select"); xml.addElement(select); select.init(); select.addAttribute("id", Vconst.select); select.addAttribute("resultMap", "BaseResultMap"); if(k_size==1)&#123; String prefix = "java.lang."; String type = MapperFactory.ktypes.get(0); if(type.equalsIgnoreCase("date"))&#123; type = "java.util.Date"; &#125;else&#123; type = prefix+type; &#125; select.addAttribute("parameterType", type); &#125; select.addText("select"); XMLBean include = new XMLBean("include"); select.addElement(include); include.init(); include.addAttribute("refid", "Base_Column_List"); select.addEndText("from "+xml.getTname()); select.addText(getEndText()); &#125; private void addDelete()&#123; XMLBean delete = new XMLBean("delete"); xml.addElement(delete); delete.init(); delete.addAttribute("id", Vconst.delete); if(k_size==1)&#123; String prefix = "java.lang."; String type = MapperFactory.ktypes.get(0); if(type.equalsIgnoreCase("date"))&#123; type = "java.util.Date"; &#125;else&#123; type = prefix+type; &#125; delete.addAttribute("parameterType", type); &#125; delete.addText("delete from "+xml.getTname()); delete.addText(getEndText()); &#125; private void addInsert1()&#123; XMLBean insert = new XMLBean("insert"); xml.addElement(insert); insert.init(); insert.addAttribute("id", Vconst.insert); insert.addAttribute("parameterType", xml.getPojo()); String attr = null; String jdbc = null; int count1 = 0; int count2 = 0; if(k_size&gt;0)&#123; for(String key:keys.keySet())&#123; if(attr==null)&#123; attr = "("; &#125;else&#123; attr+=","; &#125; if(jdbc==null)&#123; jdbc = "("; &#125;else&#123; jdbc+=","; &#125; if(count1&gt;10)&#123; attr+="\n"; count1=0; &#125; if(count2&gt;3)&#123; jdbc+="\n"; count2=0; &#125; count1++; count2++; attr+=key; jdbc+="#&#123;"+key+","+"jdbcType="+keys.get(key)+"&#125;"; &#125; &#125; if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; if(attr==null)&#123; attr = "("; &#125;else&#123; attr+=","; &#125; if(jdbc==null)&#123; jdbc = "("; &#125;else&#123; jdbc+=","; &#125; if(count1&gt;10)&#123; attr+="\n"; count1=0; &#125; if(count2&gt;3)&#123; jdbc+="\n"; count2=0; &#125; count1++; count2++; attr+=key; jdbc+="#&#123;"+key+","+"jdbcType="+columns.get(key)+"&#125;"; &#125; &#125; attr+=")"; jdbc+=")"; insert.addText("insert into "+xml.getTname()); insert.addText(attr); insert.addText("values"); insert.addText(jdbc); &#125; private void addInsert2()&#123; XMLBean insert = new XMLBean("insert"); xml.addElement(insert); insert.init(); insert.addAttribute("id", Vconst.insert1); insert.addAttribute("parameterType", xml.getPojo()); insert.addText("insert into "+xml.getTname()); XMLBean trim = new XMLBean("trim"); insert.addElement(trim); trim.init(); trim.addAttribute("prefix", "("); trim.addAttribute("suffix", ")"); trim.addAttribute("suffixOverrides", ","); if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; XMLBean test = new XMLBean("if"); trim.addElement(test); test.init(); test.addAttribute("test", key+" != null"); test.addText(key+","); &#125; &#125; XMLBean trim1 = new XMLBean("trim"); insert.addElement(trim1); trim1.init(); trim1.addAttribute("prefix", "values ("); trim1.addAttribute("suffix", ")"); trim1.addAttribute("suffixOverrides", ","); if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; XMLBean test = new XMLBean("if"); trim1.addElement(test); test.init(); test.addAttribute("test", key+" != null"); test.addText("#&#123;"+key+",jdbcType="+columns.get(key)+"&#125;,"); &#125; &#125; insert.addEndText(getEndText()); &#125; private void addUpdate1()&#123; XMLBean update = new XMLBean("update"); xml.addElement(update); update.init(); update.addAttribute("id", Vconst.update); update.addAttribute("parameterType", xml.getPojo()); update.addText("update "+xml.getTname()); String content = null; if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; if(content==null)&#123; content = "set "; &#125;else&#123; content+=","; &#125; content+=key+" = "+"#&#123;"+key+",jdbcType="+columns.get(key)+"&#125;\n"; &#125; &#125; update.addText(content); update.addText(getEndText()); &#125; private void addUpdate2()&#123; XMLBean update = new XMLBean("update"); xml.addElement(update); update.init(); update.addAttribute("id", Vconst.update1); update.addAttribute("parameterType", xml.getPojo()); update.addText("update "+xml.getTname()); XMLBean set = new XMLBean("set"); update.addElement(set); set.init(); if(c_size&gt;0)&#123; for(String key:columns.keySet())&#123; XMLBean test = new XMLBean("if"); set.addElement(test); test.init(); test.addAttribute("test", key+" != null"); test.addText(key+" = #&#123;"+key+",jdbcType="+columns.get(key)+"&#125;,"); &#125; &#125; update.addEndText(getEndText()); &#125; private void setEndText(String key,String value)&#123; if(!"".equals(endText))&#123; endText +=","; &#125; endText+=key+" = "+"#&#123;"+key+","+"jdbcType="+value+"&#125;"; &#125; private String getEndText()&#123; return "where "+endText; &#125; public void setK_size(int k_size) &#123; this.k_size = k_size; &#125; public void setC_size(int c_size) &#123; this.c_size = c_size; &#125; &#125; write类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/***@author vvxtoys*写入项目*/package cc.vvxtoys.vgenerator;import java.io.File;import java.util.ArrayList;import java.util.List;import cc.vvxtoys.bean.ClassBean;import cc.vvxtoys.bean.MapperBean;import cc.vvxtoys.bean.XMLBean;import cc.vvxtoys.utils.Common;public class VgeneratorWrite &#123; public static List&lt;ClassBean&gt; clazzs = new ArrayList&lt;ClassBean&gt;(); public static List&lt;MapperBean&gt; mappers = new ArrayList&lt;MapperBean&gt;(); public static List&lt;XMLBean&gt; xmls = new ArrayList&lt;XMLBean&gt;(); public void generatorFile() &#123; generatorClazz(); generatorMapper(); generatorXML(); &#125; private void generatorClazz() &#123; if (clazzs.size() &gt; 0) &#123; for (ClassBean bean : clazzs) &#123; try &#123; File file = new File(bean.getFileName()); File fileParent = file.getParentFile(); if(!fileParent.exists())&#123; fileParent.mkdirs(); &#125; if(file.exists())&#123; file.delete(); &#125; file.createNewFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Common.writeFile(bean.getFileName(), bean.getContext()); System.out.println("generator "+bean.getFileName()+" done"); &#125; &#125; &#125; private void generatorMapper() &#123; if (mappers.size() &gt; 0) &#123; for (MapperBean bean : mappers) &#123; try &#123; File file = new File(bean.getFileName()); File fileParent = file.getParentFile(); if(!fileParent.exists())&#123; fileParent.mkdirs(); &#125; if(file.exists())&#123; file.delete(); &#125; file.createNewFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Common.writeFile(bean.getFileName(), bean.getContext()); System.out.println("generator "+bean.getFileName()+" done"); &#125; &#125; &#125; private void generatorXML() &#123; if (xmls.size() &gt; 0) &#123; for (XMLBean bean : xmls) &#123; try &#123; File file = new File(bean.getFileName()); File fileParent = file.getParentFile(); if(!fileParent.exists())&#123; fileParent.mkdirs(); &#125; if(file.exists())&#123; file.delete(); &#125; file.createNewFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Common.writeFile(bean.getFileName(), bean.toString()); System.out.println("generator "+bean.getFileName()+" done"); &#125; &#125; &#125;&#125; generator类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/***@author vvxtoys*调用该类实现构建*/package cc.vvxtoys.vgenerator;import cc.vvxtoys.config.Engine;import cc.vvxtoys.factory.VgeneratorFactory;public class Vgenerator &#123; private VgeneratorFactory factory; public Vgenerator() &#123; factory = new VgeneratorFactory(); &#125; public Vgenerator(String configpath)&#123; Engine.setConfigFile(configpath); factory = new VgeneratorFactory(); &#125; public void help()&#123; System.out.println("url :数据库url"); System.out.println("name:服务名称"); System.out.println("user:用户名"); System.out.println("pass:密码"); System.out.println("targetProject:生成相对路径"); System.out.println("targetPackage:实体类包名"); System.out.println("targetMapper : mapper包名"); System.out.println("targetXML : xml包名"); System.out.println("tableName : 表名"); System.out.println("objectName : 实体名"); &#125; public void generator()&#123; factory.runProperties(); factory.close(); &#125; public void generatorAllFromDB()&#123; factory.runDB(); factory.close(); &#125;&#125; generator工厂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package cc.vvxtoys.factory;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import cc.vvxtoys.bean.BaseBean;import cc.vvxtoys.bean.ClassBean;import cc.vvxtoys.bean.DBtype;import cc.vvxtoys.bean.JdbcType;import cc.vvxtoys.bean.MapperBean;import cc.vvxtoys.bean.XMLBean;import cc.vvxtoys.config.DB;import cc.vvxtoys.config.Engine;import cc.vvxtoys.utils.Common;import cc.vvxtoys.utils.Vconst;import cc.vvxtoys.vgenerator.SqlGenerator;import cc.vvxtoys.vgenerator.VgeneratorWrite;public class VgeneratorFactory &#123; private VgeneratorWrite write = new VgeneratorWrite(); private Engine engine = Engine.getInstance(); private ClassFactory cF; private MapperFactory mF; private XMLFactory xF; public void runProperties()&#123; DB db = DB.getInstance(); String [] tableNames = Engine.tableName; String [] objectNames = Engine.objectName; if(tableNames.length!=objectNames.length)&#123; for(int i=0;i&lt;tableNames.length;i++)&#123; startOperator(tableNames[i], Common.upInitials(tableNames[i]),db); &#125; &#125;else&#123; for(int i=0;i&lt;tableNames.length;i++)&#123; startOperator(tableNames[i], objectNames[i],db); &#125; &#125; &#125; public void runDB()&#123; DB db = DB.getInstance(); try&#123; List&lt;String&gt; list = db.getTables(); for(String s:list)&#123; startOperator(s, Common.upInitials(s), db); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; private void startOperator(String tname,String oname,DB db)&#123; SqlGenerator.keys = new HashMap&lt;String, String&gt;(); SqlGenerator.columns = new HashMap&lt;String, String&gt;(); ClassBean bean = new ClassBean(oname); MapperBean mbean = new MapperBean(oname); XMLBean xbean = new XMLBean(Vconst.DEFAULT_XML_ROOT,tname,oname); List&lt;String&gt; ps = db.getPrimaryKey(tname); if(ps==null||ps.size()==0)&#123; mbean.setPrimary(false); &#125; cF = new ClassFactory(bean); mF = new MapperFactory(mbean); xF = new XMLFactory(); int k_size = 0; int c_size = 0; List&lt;String&gt; kname = new ArrayList&lt;String&gt;(); List&lt;String&gt; ktype = new ArrayList&lt;String&gt;(); boolean flag = false;//是否存在时间格式 Map&lt;String,String&gt; cs = db.getColumns(tname); for(Map.Entry&lt;String, String&gt; m:cs.entrySet())&#123; String name = m.getKey(); String type = m.getValue(); if(mbean.isPrimary()&amp;&amp;ps.contains(name))&#123; kname.add(name); ktype.add(DBtype.getModelType(type)); SqlGenerator.keys.put(name, JdbcType.getJdbcType(type)); k_size++; &#125;else&#123; SqlGenerator.columns.put(name, JdbcType.getJdbcType(type)); c_size++; &#125; cF.addAttribute(DBtype.getModelType(type), name); if(type.equalsIgnoreCase("date"))&#123; flag = true; &#125; &#125; bean.setDependency(flag); cF.autoAddMethod(); cF.addConstructor(); cF.loadClass(); MapperFactory.knames = kname; MapperFactory.ktypes = ktype; mF.loadMapper(); xF.createDoc(xbean,k_size,c_size); write.generatorFile(); &#125; public void close()&#123; engine.clear(); &#125;&#125; 流程分析 实例化Vgenerator g 实例化 VgeneratorFactory 实例化 VgeneratorWrite 实例化 Engine 读取配置文件,加载文件保存到静态属性 无参默认使用vgenerator.properties 有参方法设置自定义配置文件,该方法会设置Engine的isDefault属性 调用g.help 输出配置文件注释 调用g.generator() 读取配置文件中的表(支持多表,英文逗号隔开)，生成对应的文件 factory.runProperties() DB实例化 获得表名和实体类名 开始构建 startOperator() 获得主键和所有列,获得列名和类型，保存到SqlGenerator和MapperFactory 判断是否存在Date类型 设置classBean的dependency属性 ClassFactory 生成类文本保存到 classbean的context VgeneratorWrite 保存classbean MapperFactory根据主键生成mapper文本保存到mapperbean的context VgeneratorWrite 保存mapperbean xmlFactory创建文本 SqlGenerator根据主键生成对应xml文本保存到xmlbean VgeneratorWrite 保存xmlbean VgeneratorWrite generatorFile生成文件 factory.clear() 结束 调用g.generatorAllFromDB() 构建该数据库所有表,除了需要获取所有表，其他流程都一样。 结语第一个自己写的小项目，虽然有瑕疵，但是感觉还是蛮充实的。下一步需要加强技术了，看看编程思想和设计模式。]]></content>
      <categories>
        <category>Wheel</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>generator</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vgenerator(二)]]></title>
    <url>%2F2018%2F07%2F11%2Fvgenerator2%2F</url>
    <content type="text"><![CDATA[前言接上篇，这一篇主要的工具类和工厂类，包括数据库方法、通用方法，三个工厂。 常量1234567891011121314151617181920212223242526272829303132/***author vvxtoys*默认xml开头 *文档分隔*默认方法名*/package cc.vvxtoys.utils;public class Vconst &#123; public static final String DEFAULT_XML_ROOT = "mapper"; public static final String DEFAULT_XML_PUBLICID = "-//mybatis.org//DTD Mapper 3.0//EN"; public static final String DEFAULT_XML_SYSTEMID = "http://mybatis.org/dtd/mybatis-3-mapper.dtd"; public static final String [] ROOTELEMENT = new String[1];//根标签 public static final String SPACE = " "; public static final String LINE = "\n"; public static final String TAB = "\t"; public static final String TTAB = "\t\t"; public static final String END = ";"; public static final String SPLIT = "\n\n"; public static final String insert = "insert"; public static final String insert1 = "insertSelective"; public static final String select = "selectByPrimaryKey"; public static final String delete = "deleteByPrimaryKey"; public static final String update = "updateByPrimaryKey"; public static final String update1 = "updateByPrimaryKeySelective";&#125; 公用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package cc.vvxtoys.utils;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import cc.vvxtoys.factory.XMLFactory;public class Common &#123; //查找文件 public static String searchAbsolutePath(String filename) &#123; String absolutePath = ""; LinkedList&lt;File&gt; list = new LinkedList&lt;File&gt;(); try&#123; File src = new File(".\\src"); File file = new File(src.getCanonicalPath()); File [] files = file.listFiles(); for(int i=0;i&lt;files.length;i++)&#123; list.add(files[i]); if(files[i].getAbsolutePath().endsWith(filename))&#123; absolutePath = files[i].getAbsolutePath(); return absolutePath; &#125; &#125; while(!list.isEmpty())&#123; File tmp = list.removeFirst(); if(tmp.isDirectory())&#123; File [] fs = tmp.listFiles(); for(int j=0;j&lt;fs.length;j++)&#123; File f = fs[j]; if(f==null)&#123; continue; &#125; list.add(fs[j]); &#125; &#125; if(tmp.getAbsolutePath().endsWith(filename))&#123; absolutePath = tmp.getAbsolutePath(); return absolutePath; &#125; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return absolutePath; &#125; //首字母大写 public static String upInitials(String str)&#123; return str.substring(0,1).toUpperCase()+str.substring(1); &#125; public static void writeFile(String filePath, String str) &#123; try &#123; FileWriter fw = new FileWriter(new File(filePath), true); PrintWriter pw = new PrintWriter(fw); pw.println(str); pw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //xml拼接属性 public static String ConcatAttr(String name,String value)&#123; String template = " "+name+"="+"\""+value+"\""; return template; &#125; &#125; 数据库操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/***author vvxtoys*mysql数据库连接 *获取所有表*获取所有列*获取主键*/package cc.vvxtoys.config;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import cc.vvxtoys.factory.XMLFactory;public class DB &#123; private String url; private String name; private String user; private String pass; public Connection conn = null; public PreparedStatement pst = null; private static final String DEFAULT_URL = "jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8"; private static final String DEFAULT_NAME = "com.mysql.jdbc.Driver"; private static final String DEFAULT_USER = "root"; private static final String DEFAULT_PASS = "root"; private DB() &#123; &#125; public static DB getInstance() &#123; DB db = new DB(); db.setName(Engine.name); db.setPass(Engine.pass); db.setUrl(Engine.url); db.setUser(Engine.user); db.Connection(); return db; &#125; private void Connection()&#123; try&#123; Class.forName(name); conn=DriverManager.getConnection(url,user,pass); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public List&lt;String&gt; getTables()&#123; List&lt;String&gt; tables = new ArrayList&lt;String&gt;(); try&#123; if(conn!=null)&#123; DatabaseMetaData dbmd = conn.getMetaData(); ResultSet res = dbmd.getTables(null, null, null, new String[]&#123;"TABLE"&#125;); while (res.next()) &#123; tables.add(res.getString(3)); &#125; &#125; &#125;catch(Exception e)&#123; &#125; return tables; &#125; public Map&lt;String,String&gt; getColumns(String tablename)&#123; Map&lt;String,String&gt; result = new HashMap&lt;String, String&gt;(); String sql = "desc "+tablename; try&#123; pst = conn.prepareStatement(sql); PreparedStatement pst = this.pst; ResultSet res = pst.executeQuery(); while(res.next())&#123; String name = res.getString(1); String type = res.getString(2); result.put(name, type); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return result; &#125; public List&lt;String&gt; getPrimaryKey(String tableName)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); try&#123; DatabaseMetaData dmd = conn.getMetaData(); ResultSet result = dmd.getPrimaryKeys("", "", tableName); while(result.next())&#123; list.add(result.getString(4)); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return list; &#125; public void close()&#123; try &#123; this.conn.close(); this.pst.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void setUrl(String url) &#123; this.url = url==null||"".equals(url)?DEFAULT_URL:url; &#125; public void setName(String name) &#123; this.name = name==null||"".equals(name)?DEFAULT_NAME:name; &#125; public void setUser(String user) &#123; this.user = user==null||"".equals(user)?DEFAULT_USER:user; &#125; public void setPass(String pass) &#123; this.pass = pass==null||"".equals(pass)?DEFAULT_PASS:pass; &#125;&#125; 配置文件 vgenerator.properties123456789101112targetPackage=cc.vvxtoys.pojotargetProject=src/main/javaobjectName=RecordtableName=recordtargetMapper=cc.vvxtoys.mappertargetXML=cc.vvxtoys.mapperuser=rooturl=jdbc\:mysql\://127.0.0.1\:3306/test?useUnicode\=true&amp;characterEncoding\=utf8name=com.mysql.jdbc.Driverpass=root 基本的流程 初始化配置 初始化db 读取对应表的列 把列单位转换为java单位 开始构建 转换单位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/***author vvxtoys*这个类是我用一个笨方法得到的，创建了一个所有类型的表，然后用mybatis-generator构建出来*/package cc.vvxtoys.bean;public enum DBtype &#123; Date(",date,datetime,timestamp,year,time,"), String(",longtext,text,varchar,enum,char,mediumtext,tinytext,set,"), Double(",double,"), Integer(",int,mediumint,"), Short(",smallint,"), Byte(",tinyint,"), ByteArray(",tinyblob,mediumblob,binary,blob,longblob,varbinary,geometry,"), Object(",point,multipoint,multilinestring,multipolygon,polygon,geometrycollection,linestring,"), Long(",bigint,decimal,"), Boolean(",bit,"), Float(",float,"); private final String type; private DBtype(String type) &#123; this.type = type; &#125; public String getType() &#123; return type; &#125; public static String getModelType(String dbtype)&#123; if(dbtype.indexOf("(")!=-1)&#123; dbtype = dbtype.substring(0,dbtype.indexOf("(")); &#125; dbtype = ","+dbtype+","; for(DBtype db:DBtype.values())&#123; if(db.getType().indexOf(dbtype)!=-1)&#123; String model = db.name(); if(model.equals("ByteArray"))&#123; model = "byte[]"; &#125; return model; &#125; &#125; return "String"; &#125;&#125; 创建classFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/***@author vvxtoys*该类实现拼接java*生成属性、方法、构造,放进context*/package cc.vvxtoys.factory;import java.util.ArrayList;import java.util.List;import cc.vvxtoys.bean.ClassBean;import cc.vvxtoys.utils.Common;import cc.vvxtoys.utils.Vconst;import cc.vvxtoys.vgenerator.VgeneratorWrite;public class ClassFactory &#123; private ClassBean bean; public List&lt;String&gt; attrs; public List&lt;String&gt; types; public ClassFactory(ClassBean bean) &#123; this.bean = bean; attrs = new ArrayList&lt;String&gt;(); types = new ArrayList&lt;String&gt;(); &#125; public void addAttribute(String declare,String type,String name)&#123; StringBuffer buff = new StringBuffer(); buff.append(Vconst.TAB); buff.append(declare); buff.append(Vconst.SPACE); buff.append(type); buff.append(Vconst.SPACE); buff.append(name); buff.append(Vconst.END); buff.append(Vconst.LINE); bean.setAttributes(bean.getAttributes()+buff.toString()); attrs.add(name); types.add(type); &#125; public void addAttribute(String type,String name)&#123; addAttribute("private", type, name); &#125; public void addAttributes(String declare,String [] type,String [] name)&#123; if(type.length!=name.length)&#123; throw new IllegalArgumentException("Attribute not available"); &#125; for(int i=0;i&lt;type.length;i++)&#123; addAttribute(declare, type[i], name[i]); &#125; &#125; public void addAttributes(String [] type,String [] name)&#123; if(type.length!=name.length)&#123; throw new IllegalArgumentException("Attribute not available"); &#125; for(int i=0;i&lt;type.length;i++)&#123; addAttribute(type[i], name[i]); &#125; &#125; public void addGetMethod(String type,String name)&#123; StringBuffer buffer = new StringBuffer(); buffer.append(Vconst.TAB); buffer.append("public").append(Vconst.SPACE); buffer.append(type).append(Vconst.SPACE); buffer.append("get"); buffer.append(Common.upInitials(name)).append(Vconst.SPACE); buffer.append("("); buffer.append(")").append(Vconst.SPACE); buffer.append("&#123;").append(Vconst.LINE).append(Vconst.TTAB); buffer.append("return").append(Vconst.SPACE); buffer.append(name); buffer.append(Vconst.END); buffer.append(Vconst.LINE).append(Vconst.TAB); buffer.append("&#125;").append(Vconst.LINE); bean.setMethods(bean.getMethods()+buffer.toString()); &#125; public void addSetMethod(String type,String name)&#123; StringBuffer buffer = new StringBuffer(); buffer.append(Vconst.TAB); buffer.append("public").append(Vconst.SPACE); buffer.append("void").append(Vconst.SPACE); buffer.append("set"); buffer.append(Common.upInitials(name)).append(Vconst.SPACE); buffer.append("("); buffer.append(type).append(Vconst.SPACE); buffer.append(name); buffer.append(")").append(Vconst.SPACE); buffer.append("&#123;").append(Vconst.LINE).append(Vconst.TTAB); buffer.append("this.").append(name).append(Vconst.SPACE); buffer.append("=").append(Vconst.SPACE).append(name); buffer.append(Vconst.END); buffer.append(Vconst.LINE).append(Vconst.TAB); buffer.append("&#125;").append(Vconst.LINE); bean.setMethods(bean.getMethods()+buffer.toString()); &#125; public void addMethod(String type,String name)&#123; addGetMethod(type, name); addSetMethod(type, name); &#125; public void autoAddMethod()&#123; for(int i=0;i&lt;attrs.size();i++)&#123; addMethod(types.get(i),attrs.get(i)); &#125; &#125; public void addConstructor()&#123; StringBuffer buffer = new StringBuffer(); buffer.append(Vconst.TAB); buffer.append("public").append(Vconst.SPACE); buffer.append(bean.getClazz()).append(Vconst.SPACE); buffer.append("()").append(Vconst.SPACE); buffer.append("&#123;").append(Vconst.LINE).append(Vconst.TTAB); buffer.append("super();").append(Vconst.LINE).append(Vconst.TAB); buffer.append("&#125;").append(Vconst.LINE); buffer.append(Vconst.TAB); buffer.append("public").append(Vconst.SPACE); buffer.append(bean.getClazz()).append(Vconst.SPACE); buffer.append("("); for(int i=0;i&lt;attrs.size();i++)&#123; if(i&gt;0)&#123; buffer.append(","); &#125; buffer.append(types.get(i)).append(Vconst.SPACE).append(attrs.get(i)); &#125; buffer.append(")").append(Vconst.SPACE); buffer.append("&#123;").append(Vconst.LINE).append(Vconst.TTAB); buffer.append("super();").append(Vconst.LINE); for(int j=0;j&lt;attrs.size();j++)&#123; buffer.append(Vconst.TTAB); buffer.append("this.").append(attrs.get(j)); buffer.append(Vconst.SPACE).append("=").append(Vconst.SPACE); buffer.append(attrs.get(j)).append(Vconst.END).append(Vconst.LINE); &#125; buffer.append(Vconst.TAB); buffer.append("&#125;").append(Vconst.LINE); bean.setConstructors(bean.getConstructors()+buffer.toString()); &#125; public void loadClass(String declare)&#123; StringBuffer buff = new StringBuffer(); buff.append("package").append(Vconst.SPACE); buff.append(bean.getPackages()).append(Vconst.END); buff.append(Vconst.LINE).append(Vconst.LINE); if(bean.isDependency())&#123; buff.append("import").append(Vconst.SPACE); buff.append("java.util.Date").append(Vconst.END); buff.append(Vconst.LINE).append(Vconst.LINE); &#125; buff.append(declare).append(Vconst.SPACE); buff.append("class").append(Vconst.SPACE); buff.append(bean.getClazz()).append(Vconst.SPACE); buff.append("&#123;").append(Vconst.LINE).append(Vconst.LINE); buff.append(bean.getAttributes()); buff.append(Vconst.LINE).append(Vconst.LINE); buff.append(bean.getConstructors()); buff.append(Vconst.LINE).append(Vconst.LINE); buff.append(bean.getMethods()); buff.append(Vconst.LINE).append(Vconst.LINE); buff.append("&#125;"); bean.setContext(buff.toString()); VgeneratorWrite.clazzs.add(bean); &#125; public void loadClass()&#123; loadClass("public"); &#125;&#125; 生成Mapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/***@author vvxtoys*根据主键来生成相对的方法*没有主键只会生成insert方法*/package cc.vvxtoys.factory;import java.util.ArrayList;import java.util.List;import cc.vvxtoys.bean.MapperBean;import cc.vvxtoys.utils.Vconst;import cc.vvxtoys.vgenerator.VgeneratorWrite;public class MapperFactory &#123; private MapperBean bean; public static List&lt;String&gt; knames;//主键 public static List&lt;String&gt; ktypes;//主键类型 public MapperFactory(MapperBean bean) &#123; this.bean = bean; knames = new ArrayList&lt;String&gt;(); ktypes = new ArrayList&lt;String&gt;(); &#125; private String addKeyMethod(String method,String type) &#123; StringBuffer buffer = new StringBuffer(); buffer.append(Vconst.TAB); buffer.append(type).append(Vconst.SPACE); buffer.append(method).append("("); for (int i = 0; i &lt; knames.size(); i++) &#123; if (i &gt; 0) &#123; buffer.append(","); &#125; buffer.append(ktypes.get(i)).append(Vconst.SPACE).append(knames.get(i)); &#125; buffer.append(")").append(Vconst.END).append(Vconst.SPLIT); return buffer.toString(); &#125; private String addMethod(String method) &#123; StringBuffer buffer = new StringBuffer(); buffer.append(Vconst.TAB); buffer.append("int").append(Vconst.SPACE); buffer.append(method).append("("); buffer.append(bean.getClazz()).append(Vconst.SPACE).append("record"); buffer.append(")").append(Vconst.END).append(Vconst.SPLIT); return buffer.toString(); &#125; private String addInsertMethod() &#123; return addMethod("insert"); &#125; private String addInsertSelectiveMethod() &#123; return addMethod("insertSelective"); &#125; private String addUpdateMethod() &#123; return addMethod("updateByPrimaryKeySelective"); &#125; private String addUpdateSelectiveMethod() &#123; return addMethod("updateByPrimaryKey"); &#125; public String addSelectMethod() &#123; return addKeyMethod("selectByPrimaryKey",bean.getClazz()); &#125; private String addDeleteMethod() &#123; return addKeyMethod("deleteByPrimaryKey","int"); &#125; public void loadMapper() &#123; StringBuffer buff = new StringBuffer(); buff.append("package").append(Vconst.SPACE); buff.append(bean.getPackages()).append(Vconst.END); buff.append(Vconst.SPLIT); buff.append("import").append(Vconst.SPACE); buff.append(bean.getPojo()).append(Vconst.END); buff.append(Vconst.SPLIT); buff.append("public").append(Vconst.SPACE); buff.append("interface").append(Vconst.SPACE); buff.append(bean.getClazz()).append("Mapper").append(Vconst.SPACE); buff.append("&#123;").append(Vconst.LINE); if (bean.isPrimary()) &#123; buff.append(addDeleteMethod()); buff.append(addUpdateMethod()); buff.append(addUpdateSelectiveMethod()); buff.append(addSelectMethod()); &#125; buff.append(addInsertMethod()); buff.append(addInsertSelectiveMethod()); buff.append("&#125;"); bean.setContext(buff.toString()); VgeneratorWrite.mappers.add(bean);//保存到写入类 &#125;&#125; xml工厂类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/***@author vvxtoys**/package cc.vvxtoys.factory;import cc.vvxtoys.bean.XMLBean;import cc.vvxtoys.utils.Vconst;import cc.vvxtoys.vgenerator.SqlGenerator;import cc.vvxtoys.vgenerator.VgeneratorWrite;public class XMLFactory &#123; private double version = 1.0; private String encoding = "UTF-8"; private boolean headDeclare = true; //xml声明 private String docStart()&#123; StringBuffer buff = new StringBuffer(); buff.append("&lt;?xml version=\""); buff.append(version); buff.append("\" encoding=\""+encoding+"\""); buff.append(" ?&gt;").append(Vconst.LINE); return buff.toString(); &#125; public String addDoctype(String name, String publicId, String systemId)&#123; Vconst.ROOTELEMENT[0] = name;//设置根节点 publicId = "\""+publicId+"\""; systemId = "\""+systemId+"\""; StringBuffer buffer = new StringBuffer(headDeclare?docStart():""); buffer.append("&lt;!DOCTYPE").append(Vconst.SPACE); buffer.append(name).append(Vconst.SPACE); buffer.append("PUBLIC ").append(publicId).append(Vconst.SPACE); buffer.append(systemId).append(" &gt;"); buffer.append(Vconst.LINE); return buffer.toString(); &#125; public void createDoc(XMLBean bean,int k_size,int c_size)&#123; bean.init(); String doctype = addDoctype(Vconst.DEFAULT_XML_ROOT, Vconst.DEFAULT_XML_PUBLICID, Vconst.DEFAULT_XML_SYSTEMID); bean.addAttribute("namespace", bean.getMapper()); bean.setContext(doctype+bean.getContext()); SqlGenerator sql = new SqlGenerator(bean);//生成sql sql.setK_size(k_size); sql.setC_size(c_size); sql.generatorSql(); VgeneratorWrite.xmls.add(bean);//保存xml文本 &#125; public void setVersion(Double version) &#123; this.version = version; &#125; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; public void setHeadDeclare(boolean headDeclare) &#123; this.headDeclare = headDeclare; &#125;&#125;]]></content>
      <categories>
        <category>Wheel</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>generator</tag>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vgenerator(一)]]></title>
    <url>%2F2018%2F07%2F11%2Fvgenerator1%2F</url>
    <content type="text"><![CDATA[前言想要自己实现一个mybatis-generator类似的轮子，目前只实现MySQL部分的方法。利用下班时间，写了一个小项目，实现了这个功能。我准备分成三篇博客来写这个东西。 基类12345678910111213141516171819202122232425262728293031323334353637383940/***基类*通用方法和属性*getMapper 获取mapper 例如：cc.vvxtoys.mapper.StudentMapper*getPojo 获取实体 例如：cc.vvxtoys.pojo.Student*getFileName 生成地址*@author vvxtoys*/package cc.vvxtoys.bean;import cc.vvxtoys.config.Engine;public class BaseBean &#123; protected String clazz = "";//实体类名 protected String context = "";//bean内容 public String getClazz() &#123; return clazz==null?"":clazz; &#125; public void setClazz(String clazz) &#123; this.clazz = clazz; &#125; public String getContext() &#123; return context==null?"":context; &#125; public void setContext(String context) &#123; this.context = context; &#125; public String getMapper()&#123; return Engine.targetMapper+"."+clazz+"Mapper"; &#125; public String getPojo()&#123; return Engine.targetPackage+"."+clazz; &#125; public String getFileName() &#123; return null; &#125;&#125; Bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/***ClassBean*dependency 生成实体是否存在Date类型 存在的话导入java.util.Date*@author vvxtoys*/package cc.vvxtoys.bean;import java.io.File;import cc.vvxtoys.config.Engine;public class ClassBean extends BaseBean&#123; private String attributes = "";//属性 private String methods = "";//方法 private String constructors = "";//构造 private String packages = Engine.targetPackage; private boolean dependency = false;//依赖 public ClassBean(String clazz) &#123; this.clazz = clazz; &#125; public String getAttributes() &#123; return attributes; &#125; public void setAttributes(String attributes) &#123; this.attributes = attributes; &#125; public String getMethods() &#123; return methods; &#125; public void setMethods(String methods) &#123; this.methods = methods; &#125; public String getConstructors() &#123; return constructors; &#125; public void setConstructors(String constructors) &#123; this.constructors = constructors; &#125; public String getPackages() &#123; return packages; &#125; public boolean isDependency() &#123; return dependency; &#125; public void setDependency(boolean dependency) &#123; this.dependency = dependency; &#125; public String getFileName()&#123; return Engine.targetProject+File.separator+Engine.targetPackage.replace(".", File.separator)+File.separator+clazz+".java"; &#125; &#125; Mapper1234567891011121314151617181920212223242526272829303132333435/***MapperBean*primary 主键 一般来说建表是有的，默认为true*@author vvxtoys*/package cc.vvxtoys.bean;import java.io.File;import cc.vvxtoys.config.Engine;public class MapperBean extends BaseBean&#123; private String packages = Engine.targetMapper; private boolean primary = true; public MapperBean(String clazz) &#123; this.clazz = clazz; &#125; public boolean isPrimary() &#123; return primary; &#125; public String getPackages() &#123; return packages; &#125; public void setPrimary(boolean primary) &#123; this.primary = primary; &#125; public String getFileName() &#123; return Engine.targetProject + File.separator + Engine.targetMapper.replace(".", File.separator) + File.separator + clazz + "Mapper.java"; &#125;&#125; XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/***XmlBean*这个类其实我是不想写的，原定计划使用dom4j来实现，但是最终使用dom4j换行没有达到我想要的*效果，所以我就自己写了一个简单的xml方法，可以满足我现在的需求了。*方法就不写注释了，感觉应该能看懂*@author vvxtoys*/package cc.vvxtoys.bean;import java.io.File;import java.util.ArrayList;import java.util.List;import cc.vvxtoys.utils.Vconst;import cc.vvxtoys.config.Engine;import cc.vvxtoys.utils.Common;public class XMLBean extends BaseBean &#123; private String name;//节点名 private List&lt;XMLBean&gt; childrens = new ArrayList&lt;XMLBean&gt;();//子节点 private int cnt;//用来判断空格 private boolean isEnd = true;//是否关闭节点 private String tname;//表名 public XMLBean(String name, String tname, String clazz) &#123; this.name = name; this.tname = tname; this.clazz = clazz; if (name.equals(Vconst.ROOTELEMENT[0])) &#123; cnt = 0; &#125; &#125; public XMLBean(String name) &#123; this(name, null, null); &#125; public void init() &#123; for (int i = 0; i &lt; cnt; i++) &#123; this.context += Vconst.SPACE; &#125; context += "&lt;" + name + "&gt;"; &#125; public void addElement(XMLBean item) &#123; item.setCnt(this.cnt + 2); childrens.add(item); isEnd = false; &#125; public void addText(String text) &#123; StringBuffer buff = new StringBuffer(context); buff.append(Vconst.LINE); for (int i = 0; i &lt; cnt + 1; i++) &#123; buff.append(Vconst.SPACE); &#125; buff.append(text); context = buff.toString(); isEnd = false; &#125; public void addEndText(String text) &#123; if (childrens != null &amp;&amp; childrens.size() &gt; 0) &#123; context += Vconst.LINE; for (XMLBean i : childrens) &#123; context += i.toString(); &#125; &#125; childrens.clear(); StringBuffer buff = new StringBuffer(context); for (int i = 0; i &lt; cnt + 1; i++) &#123; buff.append(Vconst.SPACE); &#125; buff.append(text); context = buff.toString(); isEnd = false; &#125; public void addAttribute(String Qname, String value) &#123; context = context.substring(0, getSize() - 1); StringBuffer buff = new StringBuffer(context); buff.append(Common.ConcatAttr(Qname, value)); buff.append(" &gt;"); context = buff.toString(); &#125; public int getSize() &#123; return context.length(); &#125; public void setCnt(int cnt) &#123; this.cnt = cnt; &#125; public String getTname() &#123; return tname; &#125; public void setTname(String tname) &#123; this.tname = tname; &#125; public String getFileName() &#123; return Engine.targetProject + File.separator + Engine.targetXML.replace(".", File.separator) + File.separator + clazz + "Mapper.xml"; &#125; public String toString() &#123; StringBuffer buffer = new StringBuffer(context); if (isEnd) &#123; return context.substring(0, getSize() - 1) + "/&gt;\n"; &#125; buffer.append(Vconst.LINE); if (childrens != null &amp;&amp; childrens.size() &gt; 0) &#123; for (XMLBean i : childrens) &#123; buffer.append(i.toString()); &#125; &#125; for (int i = 0; i &lt; cnt; i++) &#123; buffer.append(Vconst.SPACE); &#125; buffer.append("&lt;/").append(name).append("&gt;"); buffer.append(Vconst.LINE); return buffer.toString(); &#125;&#125; 配置工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/***读取配置文件*初始化,如果没有自定义配置文件，默认全文检索默认配置文件*author vvxtoys*/package cc.vvxtoys.config;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.util.Properties;import cc.vvxtoys.utils.Common;public class Engine extends Properties&#123; /** * */ private static final long serialVersionUID = 1L; private static boolean isDefault = true; private static String DEFAULT_CONFIG = "vgenerator.properties"; public static String targetPackage;//实体类包 public static String targetProject;//项目路径 public static String targetMapper;//mapper包 public static String targetXML;//xml包 public static String [] objectName;//实体名 public static String [] tableName;//表名 public static String user; public static String pass; public static String name; public static String url; public static void setConfigFile(String path)&#123; DEFAULT_CONFIG = path; isDefault = false; &#125; private Engine() &#123; // TODO Auto-generated constructor stub &#125; public static Engine getInstance()&#123; Engine engine = null; String path = isDefault?Common.searchAbsolutePath(DEFAULT_CONFIG):DEFAULT_CONFIG; try &#123; engine = new Engine(); InputStreamReader is = new InputStreamReader(new FileInputStream(path), "UTF-8"); engine.load(is); targetPackage = (String)engine.getProperty("targetPackage"); targetProject = (String)engine.getProperty("targetProject"); targetMapper = (String)engine.getProperty("targetMapper"); targetXML = (String)engine.getProperty("targetXML"); tableName = ((String)engine.getProperty("tableName")).split(","); objectName = ((String)engine.getProperty("objectName")).split(","); user = (String)engine.getProperty("user"); pass = (String)engine.getProperty("pass"); name = (String)engine.getProperty("name"); url = (String)engine.getProperty("url"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return engine; &#125;&#125;]]></content>
      <categories>
        <category>Wheel</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>generator</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动生成构造方法、getter、setter]]></title>
    <url>%2F2018%2F07%2F10%2Fauto-getset%2F</url>
    <content type="text"><![CDATA[前言​ 一直很想知道IDE是如何自动去生成类的构造和getter、setter方法，大概是有个想法，获取当前的类，利用反射去获取属性名和类型，然后生成，所以我想自己试试。 写个模板类123456789101112131415161718192021222324package common;public class Templates &#123; public static final String T_CLASS = "package &#123;0&#125;;\n\n&#123;1&#125;public class &#123;2&#125; &#123;\n\n&#123;3&#125;\n\n&#123;5&#125;\n\n&#123;4&#125;\n&#125;"; public static final String T_GET = "\tpublic &#123;0&#125; get&#123;1&#125; () &#123;\n\t\treturn &#123;2&#125;;\n\t&#125;\n"; public static final String T_SET = "\tpublic void set&#123;0&#125;(&#123;1&#125; &#123;2&#125;) &#123;\n\t\tthis.&#123;2&#125;=&#123;2&#125;;\n\t&#125;\n"; public static final String T_ATTR1 = "\tprivate &#123;0&#125; &#123;1&#125;;\n"; public static final String T_ATTR2 = "\t\tthis.&#123;0&#125;=&#123;0&#125;;\n"; public static final String T_IMPORT = "import java.util.Date;\n\n"; public static final String T_CONSTRUCT = "\tpublic &#123;0&#125;(&#123;1&#125;) &#123;\n\t\tsuper();\n&#123;2&#125;\n\t&#125;\n"; public static String format(String pattern, String ... arguments)&#123; String format = pattern; for(int i=0;i&lt;arguments.length;i++)&#123; format = format.replace("&#123;"+i+"&#125;",arguments[i]); &#125; return format; &#125; public static String loadTemplate(String clazz,String pack,String port, String attrs,String get_set,String construct)&#123; return format(T_CLASS, clazz,pack,port,attrs,get_set,construct); &#125;&#125; 创建一个实体类123456789package cc.vvxtoys.pojo;public class Student &#123; private int id; private String name; private String sex; private String school; &#125; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package common;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.List;import org.apache.log4j.Logger;public class Common &#123; private static Logger log = Logger.getLogger(Common.class); //获得绝对路径 public static String absolutePath(String pack, String name, String suffix) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); String absolutePath = ""; try &#123; String packPath = pack.replace(".", "\\"); File src = new File(".\\src"); File file = new File(src.getCanonicalPath()); File[] fs = file.listFiles(); for (int i = 0; i &lt; fs.length; i++) &#123; if (fs[i].isDirectory()) &#123; if (fs[i].getAbsolutePath().endsWith(packPath)) &#123; absolutePath = fs[i].getAbsolutePath() + "\\" + name + suffix; return absolutePath; &#125; list.add(fs[i].getAbsolutePath()); &#125; &#125; for (int j = 0; j &lt; Integer.MAX_VALUE; j++) &#123; if (j&gt;0&amp;&amp;j == list.size() - 1) &#123; break; &#125; File tmp = new File(list.get(j)); fs = tmp.listFiles(); for (int k = 0; k &lt; fs.length; k++) &#123; if (fs[k].isDirectory()) &#123; if (fs[k].getAbsolutePath().endsWith(packPath)) &#123; absolutePath = fs[k].getAbsolutePath() + "\\" + name + suffix; return absolutePath; &#125; list.add(fs[k].getAbsolutePath()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return absolutePath; &#125; public static String loadFile(String path) &#123; File file = new File(path); String str = null; BufferedReader reader = null; StringBuffer buffer = new StringBuffer(); String charset = "utf-8"; try &#123; InputStreamReader is = new InputStreamReader(new FileInputStream(file), charset); reader = new BufferedReader(is); while ((str = reader.readLine()) != null) &#123; buffer.append(str); buffer.append("\n"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; return buffer.toString(); &#125; public static void writeFile(String filePath, String str, boolean flg) &#123; try &#123; FileWriter fw = new FileWriter(new File(filePath), flg); PrintWriter pw = new PrintWriter(fw); pw.println(str); log.info("写入成功。。。"); pw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void writeFile(String filePath, String str) &#123; try &#123; FileWriter fw = new FileWriter(new File(filePath), true); PrintWriter pw = new PrintWriter(fw); pw.println(str); log.info("写入成功。。。"); pw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //首字母大写 public static String upInitials(String str)&#123; StringBuffer buff = new StringBuffer(); buff.append(String.valueOf(str.charAt(0)).toUpperCase()); buff.append(str.toCharArray(),1,str.length()-1); return buff.toString(); &#125;&#125; 构建类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package auto_get_set;import java.lang.reflect.Field;import common.Common;import common.Templates;/** * @author vvxtoys */public class ClassGenerator &#123; private String [] attrs; private String [] types; private String absolutePath; private String context; private String clazz; public ClassGenerator(Object obj) &#123; loadClass(obj); &#125; public void loadClass(Object obj)&#123; Field [] fs = null; try&#123; String claname = obj.getClass().getSimpleName(); String suffix = ".java"; String pack = obj.getClass().getPackage().getName(); absolutePath = Common.absolutePath(pack, claname, suffix); context = Common.loadFile(absolutePath); clazz = claname; Class clazz = Class.forName(obj.getClass().getName()); fs = clazz.getDeclaredFields(); attrs = new String[fs.length]; types = new String[fs.length]; for(int i=0;i&lt;fs.length;i++)&#123; attrs[i] = fs[i].getName(); types[i] = fs[i].getType().getSimpleName(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public void autoGetSet()&#123; String str = context.substring(0,context.lastIndexOf("&#125;")); String get_set = ""; for(int i=0;i&lt;attrs.length;i++)&#123; String g1 = Templates.format(Templates.T_GET, types[i],Common.upInitials(attrs[i]),attrs[i]); String s1 = Templates.format(Templates.T_SET, Common.upInitials(attrs[i]),types[i],attrs[i]); get_set+=g1+s1; &#125; str+=get_set; str+="&#125;"; context = str; &#125; public void autoConstruct()&#123; String str = context.substring(0,context.lastIndexOf("&#125;")); String c1 = Templates.format(Templates.T_CONSTRUCT, clazz,"",""); String params = ""; String field = ""; for(int i=0;i&lt;attrs.length;i++)&#123; params+=types[i]+" "+attrs[i]+","; field+=Templates.format(Templates.T_ATTR2, attrs[i]); &#125; params = params.substring(0,params.length()-1); String c2 = Templates.format(Templates.T_CONSTRUCT, clazz,params,field); str +=c1+c2; str+="&#125;"; context = str; &#125; public void updateClass()&#123; Common.writeFile(absolutePath, context,false); &#125; public void run()&#123; autoConstruct(); autoGetSet(); updateClass(); &#125;&#125; 测试123456789101112package auto_get_set;import cc.vvxtoys.pojo.Student;public class Test &#123; public static void main(String[] args) &#123; ClassGenerator g = new ClassGenerator(new Student()); g.run(); &#125;&#125; 构建之后的实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445package cc.vvxtoys.pojo;public class Student &#123; private int id; private String name; private String sex; private String school; public Student() &#123; super(); &#125; public Student(int id,String name,String sex,String school) &#123; super(); this.id=id; this.name=name; this.sex=sex; this.school=school; &#125; public int getId () &#123; return id; &#125; public void setId(int id) &#123; this.id=id; &#125; public String getName () &#123; return name; &#125; public void setName(String name) &#123; this.name=name; &#125; public String getSex () &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex=sex; &#125; public String getSchool () &#123; return school; &#125; public void setSchool(String school) &#123; this.school=school; &#125;&#125; 结束 写写停停大概也是花费了两天的时间，东西虽然很小，也还有bug，但是还是有点成就感的。我知道IDE肯定不可能用这么蠢得实现方式，但是以我现在的想法只能这样了，还是需要多学点东西，然后我再重构这些代码。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>demo</tag>
        <tag>generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI导入demo]]></title>
    <url>%2F2018%2F07%2F10%2Fpoi-simpleDemo%2F</url>
    <content type="text"><![CDATA[前言使用上篇博文的导入方法，写一个简单的导入demo。其实有了工具类之后就没啥难度了，也就只简单的拿数据。先写个简单的，然后想办法实现动态读取吧，这样读取其实还是比较烦的，每次该模板都要改代码，说到底我还是比较懒的。 excel文件 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cc.vvxtoys.poi;public class Student &#123; private String id; private String stcode; private String stname; private String sex; private String phone; private String school; private String address; private String birthday; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getStcode() &#123; return stcode; &#125; public void setStcode(String stcode) &#123; this.stcode = stcode; &#125; public String getStname() &#123; return stname; &#125; public void setStname(String stname) &#123; this.stname = stname; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getSchool() &#123; return school; &#125; public void setSchool(String school) &#123; this.school = school; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Student(String id, String stcode, String stname, String sex, String phone, String school, String address) &#123; super(); this.id = id; this.stcode = stcode; this.stname = stname; this.sex = sex; this.phone = phone; this.school = school; this.address = address; &#125; public Student() &#123; super(); &#125; &#125; service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package cc.vvxtoys.poi;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import cc.vvxtoys.util.CommonTools;public class ExcelService &#123; private static ImportExcelUtils utils = new ImportExcelUtils(); public static Object getExcelParser(String path, String sheet, String start, String end) throws Exception &#123; InputStream is = null; if (utils.isEmpty(path)) &#123; return new FileNotFoundException("file not found"); &#125; else &#123; is = new FileInputStream(path); &#125; if (path.endsWith(ImportExcelUtils.EXCEL_2003)) &#123; HSSFWorkbook workbook = new HSSFWorkbook(is); return importXls(start, end, workbook, sheet); &#125; else if (path.endsWith(ImportExcelUtils.EXCEL_2007)) &#123; XSSFWorkbook workbook = new XSSFWorkbook(is); return importXlsx(start, end, workbook, sheet); &#125; else &#123; is.close(); return new Exception("type error"); &#125; &#125; public static Map&lt;String, Object&gt; importXls(String start, String end, HSSFWorkbook workbook, String sheet) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); List&lt;Student&gt; sList = new ArrayList&lt;&gt;(); HSSFSheet hssfSheet = null; // 如果传过来sheet页的名称,取当前sheet页,否则遍历所有sheet if (!utils.isEmpty(sheet)) &#123; hssfSheet = workbook.getSheet(sheet); &#125; else &#123; for (int i = 0; i &lt; workbook.getNumberOfSheets(); i++) &#123; hssfSheet = workbook.getSheetAt(i); int maxIndex = hssfSheet.getLastRowNum();// 获取最大下标 int startIndex = 0; int endIndex = 0; if (utils.isEmpty(start)) &#123; start = String.valueOf(0); &#125; if (utils.isEmpty(end)) &#123; end = maxIndex + String.valueOf(1); &#125; if (Integer.parseInt(start) &lt;= 1) &#123; startIndex = 1; &#125; else &#123; startIndex = Integer.parseInt(start) - 1; &#125; if (Integer.parseInt(end) &gt; maxIndex) &#123; endIndex = maxIndex + 1; &#125; else &#123; endIndex = Integer.parseInt(end); &#125; for (int j = startIndex; j &lt; endIndex; j++) &#123; Student student = new Student(); HSSFRow row = hssfSheet.getRow(j); //空行 if (utils.isBlank(row)) &#123; break; &#125; HSSFCell c1 = row.getCell(0); HSSFCell c2 = row.getCell(1); HSSFCell c3 = row.getCell(2); HSSFCell c4 = row.getCell(3); HSSFCell c5 = row.getCell(4); HSSFCell c6 = row.getCell(5); HSSFCell c7 = row.getCell(6); student.setId(CommonTools.get32UUID());//获取uuid 这个方法就不列出了，很简单 if(!utils.isEmpty(c1))&#123; String stcode = utils.getValue(c1); student.setStcode(stcode); &#125; if(!utils.isEmpty(c2))&#123; String stname = utils.getValue(c2); student.setStname(stname); &#125; if(!utils.isEmpty(c3))&#123; String sex = utils.getValue(c3); student.setSex(sex); &#125; if(!utils.isEmpty(c4))&#123; String phone = utils.getValue(c4); student.setPhone(phone); &#125; if(!utils.isEmpty(c5))&#123; String birthday = utils.getValue(c5).replaceAll("/", "-"); student.setBirthday(birthday); &#125; if(!utils.isEmpty(c6))&#123; String school = utils.getValue(c6); student.setSchool(school); &#125; if(!utils.isEmpty(c7))&#123; String address = utils.getValue(c7); student.setAddress(address); &#125; sList.add(student); &#125; &#125; &#125; result.put("sList", sList); return result; &#125; public static Map&lt;String, Object&gt; importXlsx(String start, String end, XSSFWorkbook workbook, String sheet) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); List&lt;Student&gt; sList = new ArrayList&lt;&gt;(); XSSFSheet xssfSheet = null; // 如果传过来sheet页的名称,取当前sheet页,否则遍历所有sheet if (!utils.isEmpty(sheet)) &#123; xssfSheet = workbook.getSheet(sheet); &#125; else &#123; for (int i = 0; i &lt; workbook.getNumberOfSheets(); i++) &#123; xssfSheet = workbook.getSheetAt(i); int maxIndex = xssfSheet.getLastRowNum();// 获取最大下标 int startIndex = 0; int endIndex = 0; if (utils.isEmpty(start)) &#123; start = String.valueOf(0); &#125; if (utils.isEmpty(end)) &#123; end = maxIndex + String.valueOf(1); &#125; if (Integer.parseInt(start) &lt;= 1) &#123; startIndex = 1; &#125; else &#123; startIndex = Integer.parseInt(start) - 1; &#125; if (Integer.parseInt(end) &gt; maxIndex) &#123; endIndex = maxIndex + 1; &#125; else &#123; endIndex = Integer.parseInt(end); &#125; for (int j = startIndex; j &lt; endIndex; j++) &#123; Student student = new Student(); XSSFRow row = xssfSheet.getRow(j); XSSFCell c1 = row.getCell(0); XSSFCell c2 = row.getCell(1); XSSFCell c3 = row.getCell(2); XSSFCell c4 = row.getCell(3); XSSFCell c5 = row.getCell(4); XSSFCell c6 = row.getCell(5); XSSFCell c7 = row.getCell(6); student.setId(CommonTools.get32UUID());//uuid if(!utils.isEmpty(c1))&#123; String stcode = utils.getValue(c1); student.setStcode(stcode); &#125; if(!utils.isEmpty(c2))&#123; String stname = utils.getValue(c2); student.setStname(stname); &#125; if(!utils.isEmpty(c3))&#123; String sex = utils.getValue(c3); student.setSex(sex); &#125; if(!utils.isEmpty(c4))&#123; String phone = utils.getValue(c4); student.setPhone(phone); &#125; if(!utils.isEmpty(c5))&#123; String birthday = utils.getValue(c5).replaceAll("/", "-"); student.setBirthday(birthday); &#125; if(!utils.isEmpty(c6))&#123; String school = utils.getValue(c6); student.setSchool(school); &#125; if(!utils.isEmpty(c7))&#123; String address = utils.getValue(c7); student.setAddress(address); &#125; sList.add(student); &#125; &#125; &#125; result.put("sList", sList); return result; &#125; public static void main(String[] args) throws Exception &#123; String path = "D:\\Desktop\\2.xlsx"; //文件路径 String start = "0"; //开始条数 String end = "10";//结束条数 String sheet = null;//sheet页名称 ExcelService service = new ExcelService(); Map&lt;String, Object&gt; result = (Map&lt;String, Object&gt;) service.getExcelParser(path, sheet, start, end); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>poi</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI导入工具类]]></title>
    <url>%2F2018%2F07%2F10%2FPoiExcel-import%2F</url>
    <content type="text"><![CDATA[前言导入的通用方法，包括xls、xlsx的取值方法，非空判断方法，空行判断，处理了手机号读取和日期读取格式问题。这几个方法就可以完成简单读取了，有时间我在优化下。 maven依赖123456&lt;!-- POI --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 导入工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package cc.vvxtoys.poi;import java.math.BigDecimal;import java.text.SimpleDateFormat;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDateUtil;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.xssf.usermodel.XSSFCell;public class ImportExcelUtils &#123; public static final String EXCEL_2003 = &quot;.xls&quot;; public static final String EXCEL_2007 = &quot;.xlsx&quot;; @SuppressWarnings(&quot;static-access&quot;) public String getValue(XSSFCell cell) &#123; if (cell.getCellType() == cell.CELL_TYPE_BOOLEAN) &#123; return String.valueOf(cell.getBooleanCellValue()).trim(); &#125; else if (cell.getCellType() == cell.CELL_TYPE_NUMERIC) &#123; if (HSSFDateUtil.isCellDateFormatted(cell)) &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); return String.valueOf(sdf.format(HSSFDateUtil.getJavaDate(cell.getNumericCellValue()))).trim(); &#125; BigDecimal bd = new BigDecimal(String.valueOf(cell.getNumericCellValue()).trim()); return bd.toPlainString(); &#125; else &#123; return String.valueOf(cell.getStringCellValue()).trim(); &#125; &#125; @SuppressWarnings(&quot;static-access&quot;) public String getValue(HSSFCell cell) &#123; if (cell.getCellType() == cell.CELL_TYPE_BOOLEAN) &#123; return String.valueOf(cell.getBooleanCellValue()).trim(); &#125; else if (cell.getCellType() == cell.CELL_TYPE_NUMERIC) &#123; if (HSSFDateUtil.isCellDateFormatted(cell)) &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); return String.valueOf(sdf.format(HSSFDateUtil.getJavaDate(cell.getNumericCellValue()))).trim(); &#125; BigDecimal bd = new BigDecimal(String.valueOf(cell.getNumericCellValue()).trim()); return bd.toPlainString(); &#125; else &#123; return String.valueOf(cell.getStringCellValue()).trim(); &#125; &#125; //判断空行 public boolean isBlank(Row row)&#123; for(int i=0;i&lt;row.getLastCellNum();i++)&#123; Cell cell = row.getCell(i); if(cell!=null&amp;&amp;cell.getCellType()!=cell.CELL_TYPE_BLANK)&#123; return false; &#125; &#125; return true; &#125; //非空判断 public boolean isEmpty(Object obj)&#123; if (obj instanceof HSSFCell) &#123; HSSFCell cell = (HSSFCell) obj; return getValue(cell) == null || &quot;&quot;.equals(getValue(cell)); &#125; if (obj instanceof XSSFCell) &#123; XSSFCell cell = (XSSFCell) obj; return getValue(cell) == null || &quot;&quot;.equals(getValue(cell)); &#125; return obj == null || obj.toString().trim().equals(&quot;&quot;); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日期处理]]></title>
    <url>%2F2018%2F07%2F10%2FDateUtil%2F</url>
    <content type="text"><![CDATA[前言在项目中经常会使用到日期处理的方法，花费了一点时间整理下我使用过的方法，整合成工具类，方便以后使用。 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290package cc.vvxtoys.util;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * * @author vvxtoys * @date 2018年1月6日下午9:48:02 * */public class DateUtils &#123; private static Calendar cal = Calendar.getInstance(); private static String fm = &quot;&quot;;//format month private static String fd = &quot;&quot;;//format day /** * @description 判断是否为闰年 */ public static boolean isLeapYear(int year)&#123; return (year % 400 == 0) || (year % 4 == 0 &amp;&amp; year % 100 != 0); &#125; /** * * @description 获取月天数 */ public static String getMonthDays(int year,int month)&#123; String [] days = &#123;&quot;31&quot;, null, &quot;31&quot;, &quot;30&quot;, &quot;31&quot;, &quot;30&quot;, &quot;31&quot;, &quot;31&quot;, &quot;30&quot;, &quot;31&quot;, &quot;30&quot;, &quot;31&quot;&#125;; if(isLeapYear(year))&#123; days[1]=&quot;29&quot;; &#125;else&#123; days[1]=&quot;28&quot;; &#125; return days[month-1]; &#125; /** * @description 获取时间在当前年为第几周 */ public static int getWeekOfYear(String date) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); cal.setFirstDayOfWeek(Calendar.MONDAY); String firstDay = date.substring(0, 4) + &quot;-01-01&quot;; cal.setTime(sdf.parse(firstDay)); int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK); if (dayOfWeek == 2) &#123; cal.setTime(sdf.parse(date)); int num = cal.get(Calendar.WEEK_OF_YEAR); return num; &#125; else &#123; cal.setTime(sdf.parse(date)); int num = cal.get(Calendar.WEEK_OF_YEAR) - 1; return num; &#125; &#125; /** * * @description 天计算 */ public static String addDays(String date,int num)&#123; try&#123; cal.setTime(toDate(date)); cal.add(Calendar.DATE, num); toFormatDate(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 星期 */ public static String addWeeks(String date,int num)&#123; try &#123; cal.setTime(toDate(date)); cal.add(Calendar.WEEK_OF_YEAR, num); toFormatDate(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 月 */ public static String addMonths(String date,int num)&#123; try &#123; cal.setTime(toDate(date)); cal.add(Calendar.MONTH, num); toFormatDate(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 季度 */ public static String addQuarters(String date,int num)&#123; try &#123; cal.setTime(toDate(date)); cal.add(Calendar.MONTH, num*3); toFormatDate(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 年 */ public static String addYears(String date,int num)&#123; try &#123; cal.setTime(toDate(date)); cal.add(Calendar.YEAR, num); toFormatDate(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 日期转换 */ public static Object translateDate(Object time, String pattern) &#123; Object date = new Object(); if (isEmpty(pattern)) &#123; pattern = &quot;yyyy-MM-dd&quot;; &#125; if (isEmpty(time)) &#123; time = &quot;1970-1-1&quot;; &#125; SimpleDateFormat sdf = new SimpleDateFormat(pattern); try &#123; if (time instanceof String) &#123; date = sdf.parse((String) time); &#125; else if (time instanceof Date) &#123; date = sdf.format(time); &#125; else &#123; throw new Exception(&quot;转换失败&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125; /** * * @description 当前日期为本周第几天 */ public static int getDayOfWeek(String date)&#123; try&#123; cal.setTime(toDate(date)); cal.setFirstDayOfWeek(Calendar.MONDAY); &#125;catch(ParseException e)&#123; e.printStackTrace(); &#125; return cal.get(Calendar.DAY_OF_WEEK)==1?7:cal.get(Calendar.DAY_OF_WEEK)-1; &#125; /** * * @description 周一 */ public static String getStartDayOfThisWeek(String date)&#123; return addDays(date, -(getDayOfWeek(date)-1)); &#125; /** * * @description 周日 */ public static String getEndDayOfThisWeek(String date)&#123; return addDays(date,(7-getDayOfWeek(date))); &#125; //获取当前时间 public static String getCurrentDate()&#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); return sdf.format(date); &#125; //当前时间 public static String getCurrentDate(String pattern)&#123; Date date = new Date(); if(isEmpty(pattern))&#123; pattern = &quot;yyyy-MM-dd&quot;; &#125; SimpleDateFormat sdf = new SimpleDateFormat(pattern); return sdf.format(date); &#125; /** * * @description 时间间隔 月 季度 年 *3 *12 */ public static int getSubDays(int num)&#123; Date date = new Date(); cal.setTime(date); cal.add(Calendar.MONTH, num); long time = cal.getTimeInMillis() - date.getTime(); return (int) (time / (1000 * 60 * 60 * 24)); &#125; /** * * @description 获取第几周开始时间 */ public static String getStartDayOfWeek(int year,int num)&#123; cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); cal.set(Calendar.YEAR, year); cal.set(Calendar.WEEK_OF_YEAR, num); toFormatDate(); return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 获取第几周结束时间 */ public static String getEndDayOfWeek(int year,int num)&#123; cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); cal.set(Calendar.YEAR, year); cal.set(Calendar.WEEK_OF_YEAR, num); cal.add(Calendar.DAY_OF_WEEK, 6); toFormatDate(); return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; /** * * @description 获取第几月开始时间 */ public static String getStartDayOfMonth(int year,int num)&#123; String month = num &lt; 10 ? &quot;0&quot; + num : String.valueOf(num); return year + &quot;-&quot; + month + &quot;-&quot; + &quot;01&quot;; &#125; /** * * @description 获取第几月结束时间 */ public static String getEndDayOfMonth(int year,int num)&#123; cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, num - 1); cal.set(Calendar.DATE, 1); cal.add(Calendar.MONTH, 1); cal.add(Calendar.DAY_OF_YEAR, -1); toFormatDate(); return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; //获取第几季度开始时间 public static String getStartDayOfQuarter(int year,int num)&#123; num = 3 * num - 2; String month = num &lt; 10 ? &quot;0&quot; + num : String.valueOf(num); return year + &quot;-&quot; + month + &quot;-&quot; + &quot;01&quot;; &#125; //获取第几季度结束时间 public static String getEndDayOfQuarter(int year,int num)&#123; cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, 3 * num - 1); cal.set(Calendar.DATE, 1); cal.add(Calendar.MONTH, 1); cal.add(Calendar.DAY_OF_YEAR, -1); toFormatDate(); return cal.get(Calendar.YEAR) + &quot;-&quot;+fm+&quot;-&quot;+fd; &#125; //时间间隔 public static int intervalDay(String d1,String d2)&#123; int num = 0; try&#123; long second = toDate(d2).getTime()-toDate(d1).getTime(); num=(int)(Math.abs(second)/(1000 * 60 * 60 * 24)); &#125;catch(ParseException e)&#123; e.printStackTrace(); &#125; return num; &#125; private static void toFormatDate()&#123; int month = (cal.get(Calendar.MONTH) + 1); fm = month&lt;10?&quot;0&quot;+month:String.valueOf(month); int day = cal.get(Calendar.DAY_OF_MONTH); fd = day&lt;10?&quot;0&quot;+day:String.valueOf(day); &#125; private static Date toDate(String date) throws ParseException&#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); return sdf.parse(date); &#125; private static boolean isEmpty(Object obj)&#123; return obj==null||obj.toString().trim().equals(&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
</search>